---
title: Assignment 03
author:
  - name: Dakota Alder - dkalder
    affiliations:
      - id: bu
        name: Boston University
        city: Boston
        state: MA
number-sections: true
date: '2025-9-22'
format:
  html:
    theme: cerulean
    toc: true
    toc-depth: 2
  docx: default
date-modified: today
date-format: long
execute:
  echo: false
  eval: false
  freeze: auto
---

## Loading the Dataset

```{python}

#| eval: true
#| echo: true
#| fig-align: center
import pandas as pd
import plotly.express as px
import plotly.io as pio
from pyspark.sql import SparkSession
import re
import numpy as np
import plotly.graph_objects as go
from pyspark.sql.functions import col, split, explode, regexp_replace, transform, when
from pyspark.sql import functions as F
from pyspark.sql.functions import col, monotonically_increasing_id

np.random.seed(42)

pio.renderers.default = "notebook"

# Initialize Spark Session
spark = SparkSession.builder.appName("LightcastData").getOrCreate()

# Load Data
df = spark.read.option("header", "true").option("inferSchema", "true").option("multiLine","true").option("escape", "\"").csv("data/lightcast_job_postings.csv")
df.createOrReplaceTempView("job_postings")

# Show Schema and Sample Data
#print("---This is Diagnostic check, No need to print it in the final doc---")

#df.printSchema() # comment this line when rendering the submission
#df.show(5)
```

## Data Preparation

```{python}
#| eval: true
# Casting Salary and Experience Columns
df = df.withColumn("SALARY", col("SALARY").cast("float"))\
  .withColumn("SALARY_FROM", col("SALARY_FROM").cast("float"))\
  .withColumn("SALARY_TO", col("SALARY_TO").cast("float"))\
  .withColumn("MAX_YEARS_EXPERIENCE", col("MAX_YEARS_EXPERIENCE").cast("float"))\
  .withColumn("MIN_YEARS_EXPERIENCE", col("MIN_YEARS_EXPERIENCE").cast("float"))

# Computing Medians for Salary Columns
def compute_median(sdf, col_name):
  q = sdf.approxQuantile(col_name, [0.5], .01)
  return q[0] if q else None

median_from = compute_median(df, "SALARY_FROM")
median_to = compute_median(df, "SALARY_TO")
median_salary = compute_median(df, "SALARY")

print("Medians:", median_from, median_to, median_salary)

#Inputting missing Salaries, but not experience

df = df.fillna({
  "SALARY_FROM": median_from,
  "SALARY_TO": median_to,
  "SALARY": median_salary
})

#Computing Average Salary
df = df.withColumn("Average_Salary", (col("SALARY_FROM") + col("SALARY_TO"))/2)

#Selecting Required Columns
exports_cols = [
  "EDUCATION_LEVELS_NAME",
  "REMOTE_TYPE_NAME",
  "MAX_YEARS_EXPERIENCE",
  "Average_Salary",
  "SALARY",
  "LOT_V6_SPECIALIZED_OCCUPATION_NAME"
]
df_selected = df.select(*exports_cols)

#Save to CSV
pdf = df_selected.toPandas()
pdf.to_csv("data/cleaned_data.csv", index=False)

print("Data Cleaning Complete. Rows retained:", len(pdf))
```

## Salary Distribution by Employment Type
```{python}
#| eval: true
#Question 1 Code

#Filter out  missing or zero salaries
pdf = df.filter(df["SALARY"] > 0).select("EMPLOYMENT_TYPE_NAME", "SALARY").toPandas()

#Filter out null values from Employment Type Name
pdf = pdf.dropna(subset=["EMPLOYMENT_TYPE_NAME"])

# Clean Employment type names
pdf["EMPLOYMENT_TYPE_NAME"] = pdf["EMPLOYMENT_TYPE_NAME"].apply(lambda x: re.sub(r"[^\x00-\x7F]+", "", x))

#Compute Median Salary by Employment Type
median_salaries = pdf.groupby("EMPLOYMENT_TYPE_NAME")["SALARY"].median()

#Sort Employment Types based on Median Salaries Desc
sorted_employment_types = median_salaries.sort_values(ascending=False).index

#Apply sorted categories
pdf["EMPLOYMENT_TYPE_NAME"] = pd.Categorical(
  pdf["EMPLOYMENT_TYPE_NAME"],
  categories=sorted_employment_types,
  ordered=True
)

#Create box plot with Horizontal grid lines
fig = px.box(
  pdf,
  x="EMPLOYMENT_TYPE_NAME",
  y="SALARY",
  title="Salary Distribution by Employment Type",
  color_discrete_sequence=["blue"],
  boxmode="group",
  points="all",
)



fig.update_layout(
  title=dict(
      text="Salary Distribution by Employment Type",
      font=dict(size=25, family="Arial", color="black", weight="bold")
  ),
  xaxis=dict(
    title=dict(text="Employment Type", font=dict(size=24, family="Arial", color="black", weight="bold")),
    tickangle=0,
    tickfont=dict(size=18, family="Arial", color="black",weight="bold"),
    showline=True,
    linewidth=2,
    linecolor="black",
    mirror=True,
    showgrid=False,
    categoryorder="array",
    categoryarray=sorted_employment_types.tolist()
  ),
  yaxis=dict(
    title=dict(text="Salary (K $)", font=dict(size=24, family="Arial", color="black", weight="bold")),
    tickvals=[0,50000,100000,150000,200000,250000,300000,350000,400000,450000,500000],
    ticktext=["0","50K","100K","150K","200K","250K","300K","350K","400K","450K","500K"],
    tickfont=dict(size=18, family="Arial", color="black",weight="bold"),
    showline=True,
    linewidth=2,
    linecolor="black",
    mirror=True,
    showgrid=False,
    gridcolor="lightgray",
    gridwidth=.5
  ),
  font=dict(family="Arial", size=16, color="black"),
  boxgap=0.7,
  plot_bgcolor="white",
  paper_bgcolor="white",
  showlegend=False,
  height=500,
  width=850,
)
fig.show()
fig.write_html("output/Q1.html")
#fig.write_image("output/Q1.svg", width=850, height=500, scale=1)

```

## Salary Distribution by Industry
```{python}
#| eval: true
#| echo: true
#| fig-align: center
#Question 2 Code

#Select Industry and Salary Columns
pdf = df.select("NAICS2_NAME", "SALARY_FROM").toPandas()


#Create box plot with Horizontal grid lines
fig = px.box(
  pdf,
  x="NAICS2_NAME",
  y="SALARY_FROM",
  title="Salary Distribution by Industry",
  color_discrete_sequence=["blue"],
  boxmode="group",
  points="all",
)



fig.update_layout(
  title=dict(
      text="Salary Distribution by Industry",
      font=dict(size=25, family="Arial", color="black", weight="bold")
  ),
  xaxis=dict(
    title=dict(text="Industry", font=dict(size=24, family="Arial", color="black", weight="bold")),
    tickangle=45,
    tickfont=dict(size=12, family="Arial", color="black",weight="bold"),
    showline=True,
    linewidth=2,
    linecolor="black",
    mirror=True,
    showgrid=False,
    categoryorder="array",
    categoryarray=sorted_employment_types.tolist()
  ),
  yaxis=dict(
    title=dict(text="Salary (K $)", font=dict(size=24, family="Arial", color="black", weight="bold")),
    tickvals=[0,50000,100000,150000,200000,250000,300000,350000,400000,450000,500000],
    ticktext=["0","50K","100K","150K","200K","250K","300K","350K","400K","450K","500K"],
    tickfont=dict(size=18, family="Arial", color="black",weight="bold"),
    showline=True,
    linewidth=2,
    linecolor="black",
    mirror=True,
    showgrid=False,
    gridcolor="lightgray",
    gridwidth=.5
  ),
  font=dict(family="Arial", size=16, color="black"),
  boxgap=0.7,
  plot_bgcolor="white",
  paper_bgcolor="white",
  showlegend=False,
  height=800,
  width=1000,
)
fig.show()
fig.write_html("output/Q2.html")
#fig.write_image("output/Q2.svg", width=850, height=500, scale=1)

```

## Question 2: Salary Analysis by ONET Occupation Type
```{python}
#| eval: true
#| echo: true

#Query the required data with Spark SQL

onet_type = spark.sql("""
  SELECT LOT_OCCUPATION_NAME AS Occupation_Name, PERCENTILE(SALARY, 0.5) As Median_Salary, COUNT(*) As Job_Postings
  FROM job_postings
  GROUP BY LOT_OCCUPATION_NAME
  ORDER BY Job_Postings DESC
  LIMIT 10
  """)

onet_pd = onet_type.toPandas()

fig = px.scatter(
  onet_pd,
  x="Occupation_Name",
  y="Median_Salary",
  size="Job_Postings",
  title="Salary Analysis by Occupation Name (Bubble Chart)",
  labels={
    "Occupation_Name": "Occupation Name",
    "Median_Salary": "Median Salary",
    "Job_Postings": "Number of Job Postings"
  },
  hover_name="Occupation_Name",
  size_max=60,
  width=1000,
  height=600,
  color="Job_Postings",
  color_continuous_scale="Plasma"
)

fig.update_layout(
  font_family="Arial",
  font_size=12,
  title_font_size=24,
  xaxis_title="Occupation Name",
  yaxis_title="Median Salary",
  plot_bgcolor="white",
  xaxis=dict(
    tickangle=-45,
    showline=True,
    linecolor="black"
  ),
  yaxis=dict(
    showline=True,
    linecolor="black"
  )
)
fig.show()
fig.write_html("output/Q3.html")





```
